"""
Farm Task Repository - Data Access Layer

Handles all database operations for farm tasks.
"""

from typing import List, Optional, Tuple, Dict
from uuid import UUID
from datetime import datetime
import logging

from ...models.farm_task import (
    FarmTask, FarmTaskCreate, FarmTaskUpdate,
    TaskType, TaskStatus, HarvestEntry, HarvestEntryCreate,
    HarvestTotal, TaskData
)
from ..database import farm_db

logger = logging.getLogger(__name__)


class TaskRepository:
    """Repository for FarmTask data access"""

    @staticmethod
    async def create(task_data: FarmTaskCreate, is_auto_generated: bool = False,
                    generated_from_cycle_id: Optional[UUID] = None) -> FarmTask:
        """
        Create a new farm task

        Args:
            task_data: Task creation data
            is_auto_generated: Whether task was auto-generated
            generated_from_cycle_id: Block cycle that generated this task

        Returns:
            Created FarmTask
        """
        db = farm_db.get_database()

        # Create task document
        task = FarmTask(
            **task_data.model_dump(),
            isAutoGenerated=is_auto_generated,
            generatedFromCycleId=generated_from_cycle_id
        )

        # Convert UUIDs to strings for MongoDB
        task_dict = task.model_dump()
        task_dict["taskId"] = str(task_dict["taskId"])
        task_dict["farmId"] = str(task_dict["farmId"])
        task_dict["blockId"] = str(task_dict["blockId"])
        if task_dict.get("assignedTo"):
            task_dict["assignedTo"] = str(task_dict["assignedTo"])
        if task_dict.get("completedBy"):
            task_dict["completedBy"] = str(task_dict["completedBy"])
        if task_dict.get("generatedFromCycleId"):
            task_dict["generatedFromCycleId"] = str(task_dict["generatedFromCycleId"])

        # Convert task data properly
        if task_dict.get("taskData"):
            task_data_obj = task_dict["taskData"]
            if task_data_obj.get("harvestEntries"):
                for entry in task_data_obj["harvestEntries"]:
                    entry["entryId"] = str(entry["entryId"])
                    entry["userId"] = str(entry["userId"])
            if task_data_obj.get("totalHarvest") and task_data_obj["totalHarvest"].get("contributors"):
                task_data_obj["totalHarvest"]["contributors"] = [
                    str(uid) for uid in task_data_obj["totalHarvest"]["contributors"]
                ]

        result = await db.farm_tasks.insert_one(task_dict)

        if not result.inserted_id:
            raise Exception("Failed to create farm task")

        logger.info(f"Created farm task: {task.taskId} ({task.taskType}) for block {task.blockId}")
        return task

    @staticmethod
    async def get_by_id(task_id: UUID) -> Optional[FarmTask]:
        """Get task by ID"""
        db = farm_db.get_database()

        task_doc = await db.farm_tasks.find_one({"taskId": str(task_id)})
        if not task_doc:
            return None

        # Remove MongoDB _id
        task_doc.pop("_id", None)

        return FarmTask(**task_doc)

    @staticmethod
    async def get_by_farm(
        farm_id: UUID,
        status: Optional[TaskStatus] = None,
        page: int = 1,
        per_page: int = 50
    ) -> Tuple[List[FarmTask], int]:
        """
        Get tasks for a farm

        Args:
            farm_id: Farm ID
            status: Optional status filter
            page: Page number
            per_page: Results per page

        Returns:
            Tuple of (tasks list, total count)
        """
        db = farm_db.get_database()

        # Build query
        query: Dict = {"farmId": str(farm_id)}
        if status:
            query["status"] = status.value

        # Get total count
        total = await db.farm_tasks.count_documents(query)

        # Get paginated results sorted by scheduled date
        skip = (page - 1) * per_page
        cursor = db.farm_tasks.find(query).sort("scheduledDate", 1).skip(skip).limit(per_page)

        tasks = []
        async for task_doc in cursor:
            task_doc.pop("_id", None)
            tasks.append(FarmTask(**task_doc))

        return tasks, total

    @staticmethod
    async def get_by_block(
        block_id: UUID,
        status: Optional[TaskStatus] = None,
        page: int = 1,
        per_page: int = 50
    ) -> Tuple[List[FarmTask], int]:
        """
        Get tasks for a block

        Args:
            block_id: Block ID
            status: Optional status filter
            page: Page number
            per_page: Results per page

        Returns:
            Tuple of (tasks list, total count)
        """
        db = farm_db.get_database()

        # Build query
        query: Dict = {"blockId": str(block_id)}
        if status:
            query["status"] = status.value

        # Get total count
        total = await db.farm_tasks.count_documents(query)

        # Get paginated results sorted by scheduled date
        skip = (page - 1) * per_page
        cursor = db.farm_tasks.find(query).sort("scheduledDate", 1).skip(skip).limit(per_page)

        tasks = []
        async for task_doc in cursor:
            task_doc.pop("_id", None)
            tasks.append(FarmTask(**task_doc))

        return tasks, total

    @staticmethod
    async def get_by_user(
        user_id: UUID,
        status: Optional[TaskStatus] = None,
        page: int = 1,
        per_page: int = 50
    ) -> Tuple[List[FarmTask], int]:
        """
        Get tasks assigned to a specific user

        Args:
            user_id: User ID
            status: Optional status filter
            page: Page number
            per_page: Results per page

        Returns:
            Tuple of (tasks list, total count)
        """
        db = farm_db.get_database()

        # Build query for assigned tasks
        query: Dict = {"assignedTo": str(user_id)}
        if status:
            query["status"] = status.value

        # Get total count
        total = await db.farm_tasks.count_documents(query)

        # Get paginated results sorted by due date
        skip = (page - 1) * per_page
        cursor = db.farm_tasks.find(query).sort("dueDate", 1).skip(skip).limit(per_page)

        tasks = []
        async for task_doc in cursor:
            task_doc.pop("_id", None)
            tasks.append(FarmTask(**task_doc))

        return tasks, total

    @staticmethod
    async def get_my_tasks(
        farm_id: UUID,
        user_id: UUID,
        status: Optional[TaskStatus] = None
    ) -> List[FarmTask]:
        """
        Get tasks visible to a user (auto-tasks for their farms + tasks assigned to them)

        Args:
            farm_id: Farm ID
            user_id: User ID
            status: Optional status filter

        Returns:
            List of tasks
        """
        db = farm_db.get_database()

        # Build query: auto-tasks on this farm OR tasks assigned to user
        query: Dict = {
            "$or": [
                {"farmId": str(farm_id), "assignedTo": None},  # Auto-tasks
                {"assignedTo": str(user_id)}  # Assigned tasks
            ]
        }

        if status:
            query["status"] = status.value

        cursor = db.farm_tasks.find(query).sort("scheduledDate", 1)

        tasks = []
        async for task_doc in cursor:
            task_doc.pop("_id", None)
            tasks.append(FarmTask(**task_doc))

        return tasks

    @staticmethod
    async def count_pending_tasks(user_id: UUID, farm_ids: List[UUID]) -> int:
        """
        Count pending tasks for a user across their assigned farms

        Args:
            user_id: User ID
            farm_ids: List of farm IDs user is assigned to

        Returns:
            Count of pending tasks
        """
        db = farm_db.get_database()

        farm_id_strs = [str(fid) for fid in farm_ids]

        query: Dict = {
            "status": TaskStatus.PENDING.value,
            "$or": [
                {"farmId": {"$in": farm_id_strs}, "assignedTo": None},  # Auto-tasks
                {"assignedTo": str(user_id)}  # Assigned tasks
            ]
        }

        return await db.farm_tasks.count_documents(query)

    @staticmethod
    async def update(task_id: UUID, update_data: FarmTaskUpdate) -> Optional[FarmTask]:
        """
        Update a farm task

        Args:
            task_id: Task ID
            update_data: Update data

        Returns:
            Updated FarmTask or None if not found
        """
        db = farm_db.get_database()

        # Build update document
        update_dict = update_data.model_dump(exclude_unset=True)
        if not update_dict:
            # No updates provided
            return await TaskRepository.get_by_id(task_id)

        # Convert status enum to value if present
        if "status" in update_dict and isinstance(update_dict["status"], TaskStatus):
            update_dict["status"] = update_dict["status"].value

        # Add updatedAt timestamp
        update_dict["updatedAt"] = datetime.utcnow()

        result = await db.farm_tasks.update_one(
            {"taskId": str(task_id)},
            {"$set": update_dict}
        )

        if result.matched_count == 0:
            return None

        return await TaskRepository.get_by_id(task_id)

    @staticmethod
    async def complete_task(
        task_id: UUID,
        user_id: UUID,
        user_email: str,
        task_data: TaskData
    ) -> Optional[FarmTask]:
        """
        Mark a task as completed

        Args:
            task_id: Task ID
            user_id: User who completed the task
            user_email: Email of user
            task_data: Completion data

        Returns:
            Updated FarmTask or None if not found
        """
        db = farm_db.get_database()

        update_dict = {
            "status": TaskStatus.COMPLETED.value,
            "completedBy": str(user_id),
            "completedByEmail": user_email,
            "completedAt": datetime.utcnow(),
            "taskData": task_data.model_dump(),
            "updatedAt": datetime.utcnow()
        }

        result = await db.farm_tasks.update_one(
            {"taskId": str(task_id)},
            {"$set": update_dict}
        )

        if result.matched_count == 0:
            return None

        logger.info(f"Task {task_id} completed by {user_email}")
        return await TaskRepository.get_by_id(task_id)

    @staticmethod
    async def add_harvest_entry(
        task_id: UUID,
        user_id: UUID,
        user_email: str,
        entry_data: HarvestEntryCreate
    ) -> Optional[FarmTask]:
        """
        Add a harvest entry to a daily_harvest task

        Args:
            task_id: Task ID
            user_id: User recording harvest
            user_email: Email of user
            entry_data: Harvest entry data

        Returns:
            Updated FarmTask or None if not found
        """
        db = farm_db.get_database()

        # Create harvest entry
        entry = HarvestEntry(
            **entry_data.model_dump(),
            userId=user_id,
            userEmail=user_email
        )

        entry_dict = entry.model_dump()
        entry_dict["entryId"] = str(entry_dict["entryId"])
        entry_dict["userId"] = str(entry_dict["userId"])

        # Add to harvestEntries array (keep status as pending - will auto-complete at 11 PM)
        result = await db.farm_tasks.update_one(
            {"taskId": str(task_id)},
            {
                "$push": {"taskData.harvestEntries": entry_dict},
                "$set": {
                    "updatedAt": datetime.utcnow()
                }
            }
        )

        if result.matched_count == 0:
            return None

        logger.info(f"Added harvest entry to task {task_id}: {entry_data.quantity}kg grade {entry_data.grade}")
        return await TaskRepository.get_by_id(task_id)

    @staticmethod
    async def aggregate_daily_harvest(task_id: UUID) -> Optional[FarmTask]:
        """
        Aggregate all harvest entries for a daily harvest task

        Called by midnight cron job to finalize daily harvests.
        Also creates a harvest record and updates block KPI.

        Args:
            task_id: Task ID

        Returns:
            Updated FarmTask with aggregated totals
        """
        db = farm_db.get_database()

        # Get task
        task = await TaskRepository.get_by_id(task_id)
        if not task or task.taskType != TaskType.DAILY_HARVEST:
            return None

        # Calculate totals from harvest entries
        total_quantity = 0.0
        grade_breakdown: Dict[str, float] = {}
        contributors: List[str] = []

        if task.taskData.harvestEntries:
            for entry in task.taskData.harvestEntries:
                total_quantity += entry.quantity
                grade_key = entry.grade.value
                grade_breakdown[grade_key] = grade_breakdown.get(grade_key, 0.0) + entry.quantity

                user_id_str = str(entry.userId)
                if user_id_str not in contributors:
                    contributors.append(user_id_str)

        # Create harvest total
        harvest_total = HarvestTotal(
            totalQuantity=total_quantity,
            gradeBreakdown=grade_breakdown,  # type: ignore
            contributors=[UUID(uid) for uid in contributors],
            entryCount=len(task.taskData.harvestEntries) if task.taskData.harvestEntries else 0
        )

        # Update task with aggregated total and mark as completed
        update_dict = {
            "taskData.totalHarvest": harvest_total.model_dump(),
            "status": TaskStatus.COMPLETED.value,
            "completedAt": datetime.utcnow(),
            "updatedAt": datetime.utcnow()
        }

        # Convert contributors to strings for MongoDB
        update_dict["taskData.totalHarvest"]["contributors"] = contributors

        result = await db.farm_tasks.update_one(
            {"taskId": str(task_id)},
            {"$set": update_dict}
        )

        if result.matched_count == 0:
            return None

        # Create harvest record and update block KPI
        if total_quantity > 0:
            from ...models.block_harvest import BlockHarvestCreate, QualityGrade
            from ..block.harvest_service import HarvestService

            try:
                # Determine best quality grade for the harvest record
                best_grade = QualityGrade.A  # Default
                if grade_breakdown:
                    # Use the grade with highest quantity
                    best_grade_str = max(grade_breakdown.items(), key=lambda x: x[1])[0]
                    # Convert to QualityGrade enum (only A, B, C supported)
                    if best_grade_str in ["A", "B", "C"]:
                        best_grade = QualityGrade(best_grade_str)

                # Use task's scheduled date as harvest date
                harvest_date = task.scheduledDate

                # Create harvest record
                harvest_create = BlockHarvestCreate(
                    blockId=task.blockId,
                    harvestDate=harvest_date,
                    quantityKg=total_quantity,
                    qualityGrade=best_grade,
                    notes=f"Daily harvest aggregation from {len(task.taskData.harvestEntries) if task.taskData.harvestEntries else 0} entries"
                )

                # Use first contributor as harvester (or system if none)
                harvester_id = UUID(contributors[0]) if contributors else task.farmId
                harvester_email = task.taskData.harvestEntries[0].userEmail if task.taskData.harvestEntries else "system@a64core.com"

                await HarvestService.record_harvest(
                    harvest_create,
                    harvester_id,
                    harvester_email
                )

                logger.info(f"Created harvest record for task {task_id}: {total_quantity}kg (grade {best_grade.value})")
            except Exception as e:
                logger.error(f"Failed to create harvest record for task {task_id}: {e}", exc_info=True)
                # Don't fail the aggregation if harvest record creation fails

        logger.info(f"Aggregated daily harvest task {task_id}: {total_quantity}kg from {len(contributors)} farmers")
        return await TaskRepository.get_by_id(task_id)

    @staticmethod
    async def get_daily_harvest_tasks_to_aggregate(scheduled_date: datetime) -> List[FarmTask]:
        """
        Get daily harvest tasks that need aggregation

        Called by midnight cron job to find tasks scheduled for today that are in_progress.

        Args:
            scheduled_date: Date to find tasks for (should be today's date)

        Returns:
            List of tasks to aggregate
        """
        db = farm_db.get_database()

        # Find daily harvest tasks scheduled for today that are in_progress
        query = {
            "taskType": TaskType.DAILY_HARVEST.value,
            "status": TaskStatus.IN_PROGRESS.value,
            "scheduledDate": {
                "$gte": scheduled_date,
                "$lt": datetime(scheduled_date.year, scheduled_date.month, scheduled_date.day, 23, 59, 59)
            }
        }

        cursor = db.farm_tasks.find(query)

        tasks = []
        async for task_doc in cursor:
            task_doc.pop("_id", None)
            tasks.append(FarmTask(**task_doc))

        return tasks

    @staticmethod
    async def cancel_future_tasks_for_cycle(cycle_id: UUID, task_types: List[TaskType]) -> int:
        """
        Cancel future auto-generated tasks for a block cycle

        Used when harvest ends early or block is reset.

        Args:
            cycle_id: Block cycle ID
            task_types: List of task types to cancel

        Returns:
            Number of tasks cancelled
        """
        db = farm_db.get_database()

        task_type_values = [tt.value for tt in task_types]

        result = await db.farm_tasks.update_many(
            {
                "generatedFromCycleId": str(cycle_id),
                "taskType": {"$in": task_type_values},
                "status": TaskStatus.PENDING.value,
                "scheduledDate": {"$gt": datetime.utcnow()}
            },
            {
                "$set": {
                    "status": TaskStatus.CANCELLED.value,
                    "updatedAt": datetime.utcnow()
                }
            }
        )

        logger.info(f"Cancelled {result.modified_count} future tasks for cycle {cycle_id}")
        return result.modified_count

    @staticmethod
    async def reschedule_tasks_for_cycle(
        cycle_id: UUID,
        task_type: TaskType,
        new_scheduled_dates: List[datetime]
    ) -> int:
        """
        Reschedule auto-generated tasks when block timeline changes

        Args:
            cycle_id: Block cycle ID
            task_type: Task type to reschedule
            new_scheduled_dates: New scheduled dates (one per task)

        Returns:
            Number of tasks rescheduled
        """
        db = farm_db.get_database()

        # Get existing tasks
        cursor = db.farm_tasks.find({
            "generatedFromCycleId": str(cycle_id),
            "taskType": task_type.value,
            "status": TaskStatus.PENDING.value
        }).sort("scheduledDate", 1)

        tasks = []
        async for task_doc in cursor:
            tasks.append(task_doc)

        # Update each task with new scheduled date
        updated_count = 0
        for i, task_doc in enumerate(tasks):
            if i < len(new_scheduled_dates):
                await db.farm_tasks.update_one(
                    {"taskId": task_doc["taskId"]},
                    {
                        "$set": {
                            "scheduledDate": new_scheduled_dates[i],
                            "updatedAt": datetime.utcnow()
                        }
                    }
                )
                updated_count += 1

        logger.info(f"Rescheduled {updated_count} {task_type} tasks for cycle {cycle_id}")
        return updated_count

    @staticmethod
    async def delete(task_id: UUID) -> bool:
        """
        Delete a farm task

        Args:
            task_id: Task ID

        Returns:
            True if deleted, False if not found
        """
        db = farm_db.get_database()

        result = await db.farm_tasks.delete_one({"taskId": str(task_id)})

        if result.deleted_count > 0:
            logger.info(f"Deleted farm task: {task_id}")
            return True

        return False

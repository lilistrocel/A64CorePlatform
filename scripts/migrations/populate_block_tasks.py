#!/usr/bin/env python3
"""
Populate Block Tasks Script

Creates appropriate tasks for blocks based on their current state.
Since block states were synced manually from OldData, no tasks were
automatically created during the lifecycle transitions.

Task Types by State:
- PLANNED: Planting task
- GROWING: Harvest readiness task (check when ready to harvest)
- HARVESTING: Daily harvest task (for today)
- CLEANING: Cleaning task

Note: We skip FRUITING_CHECK as most OldData blocks don't have fruiting stage info.
"""

import asyncio
import argparse
from datetime import datetime, timezone, timedelta
from typing import Dict, List, Optional
from uuid import UUID, uuid4
from motor.motor_asyncio import AsyncIOMotorClient

# MongoDB Connection
MONGO_URI = "mongodb://mongodb:27017"
DB_NAME = "a64core_db"

# System user for migration records
SYSTEM_USER_ID = "00000000-0000-0000-0000-000000000001"
SYSTEM_USER_EMAIL = "migration@a64platform.com"

# Task types
TASK_TYPES = {
    "planting": "planting",
    "fruiting_check": "fruiting_check",
    "harvest_readiness": "harvest_readiness",
    "daily_harvest": "daily_harvest",
    "harvest_completion": "harvest_completion",
    "cleaning": "cleaning",
    "custom": "custom",
}


class TaskPopulator:
    def __init__(self, dry_run: bool = False):
        self.client = None
        self.db = None
        self.dry_run = dry_run

        # Statistics
        self.stats = {
            "blocks_processed": 0,
            "tasks_created": 0,
            "blocks_skipped": 0,
            "tasks_by_type": {
                "planting": 0,
                "harvest_readiness": 0,
                "daily_harvest": 0,
                "cleaning": 0,
            },
            "blocks_with_existing_tasks": 0,
        }

    async def connect(self):
        """Connect to MongoDB."""
        self.client = AsyncIOMotorClient(MONGO_URI)
        self.db = self.client[DB_NAME]
        print(f"Connected to MongoDB: {MONGO_URI}/{DB_NAME}")
        if self.dry_run:
            print("*** DRY RUN MODE - No changes will be made ***")

    async def close(self):
        """Close MongoDB connection."""
        if self.client:
            self.client.close()

    async def get_non_empty_blocks(self) -> List[Dict]:
        """Get all blocks that are not empty."""
        query = {
            "state": {"$in": ["planned", "growing", "fruiting", "harvesting", "cleaning"]},
            "isActive": True,
        }

        cursor = self.db["blocks"].find(query)
        blocks = await cursor.to_list(None)

        # Group by state for summary
        state_counts = {}
        for block in blocks:
            state = block.get("state", "unknown")
            state_counts[state] = state_counts.get(state, 0) + 1

        print(f"\nFound {len(blocks)} non-empty blocks:")
        for state, count in sorted(state_counts.items()):
            print(f"  {state}: {count}")

        return blocks

    async def has_pending_tasks(self, block_id: str) -> bool:
        """Check if block already has pending tasks."""
        count = await self.db["farm_tasks"].count_documents({
            "blockId": block_id,
            "status": "pending"
        })
        return count > 0

    def create_task_document(
        self,
        farm_id: str,
        block_id: str,
        task_type: str,
        title: str,
        description: str,
        scheduled_date: datetime,
        due_date: datetime,
        trigger_state_change: Optional[str] = None
    ) -> Dict:
        """Create a task document ready for insertion."""
        now = datetime.now(timezone.utc)
        task_id = str(uuid4())

        return {
            "taskId": task_id,
            "farmId": farm_id,
            "blockId": block_id,
            "taskType": task_type,
            "title": title,
            "description": description,
            "scheduledDate": scheduled_date,
            "dueDate": due_date,
            "assignedTo": None,
            "status": "pending",
            "taskData": {
                "harvestEntries": [],
                "totalHarvest": None,
                "notes": None,
                "photoUrls": []
            },
            "completedBy": None,
            "completedByEmail": None,
            "completedAt": None,
            "isAutoGenerated": True,
            "generatedFromCycleId": None,
            "triggerStateChange": trigger_state_change,
            "createdAt": now,
            "updatedAt": now,
        }

    async def create_task_for_block(self, block: Dict) -> Optional[Dict]:
        """Create appropriate task based on block state."""
        block_id = block.get("blockId")
        farm_id = block.get("farmId")
        state = block.get("state")
        block_name = block.get("name") or block.get("blockCode") or block_id[:8]
        crop_name = block.get("targetCropName") or "crops"

        now = datetime.now(timezone.utc)
        today = now.replace(hour=0, minute=0, second=0, microsecond=0)

        task = None

        if state == "planned":
            # Create planting task
            # Use plantedDate if available, otherwise tomorrow
            planted_date = block.get("plantedDate")
            if planted_date:
                if isinstance(planted_date, str):
                    scheduled_date = datetime.fromisoformat(planted_date.replace("Z", "+00:00"))
                else:
                    scheduled_date = planted_date
            else:
                scheduled_date = today + timedelta(days=1)

            task = self.create_task_document(
                farm_id=farm_id,
                block_id=block_id,
                task_type="planting",
                title=f"Plant {crop_name}",
                description=f"Plant {crop_name} in Block {block_name}",
                scheduled_date=scheduled_date,
                due_date=scheduled_date + timedelta(days=1),
                trigger_state_change="growing"
            )
            self.stats["tasks_by_type"]["planting"] += 1

        elif state in ["growing", "fruiting"]:
            # Create harvest readiness task
            # Use expectedHarvestDate if available
            harvest_date = block.get("expectedHarvestDate")
            if harvest_date:
                if isinstance(harvest_date, str):
                    harvest_date = datetime.fromisoformat(harvest_date.replace("Z", "+00:00"))
                scheduled_date = harvest_date - timedelta(days=2)
                due_date = harvest_date
            else:
                # Default: check in 7 days
                scheduled_date = today + timedelta(days=7)
                due_date = scheduled_date + timedelta(days=3)

            task = self.create_task_document(
                farm_id=farm_id,
                block_id=block_id,
                task_type="harvest_readiness",
                title=f"Check harvest readiness for {crop_name}",
                description=f"Check if {block_name} ({crop_name}) is ready for harvest",
                scheduled_date=scheduled_date,
                due_date=due_date,
                trigger_state_change="harvesting"
            )
            self.stats["tasks_by_type"]["harvest_readiness"] += 1

        elif state == "harvesting":
            # Create daily harvest task for today
            task = self.create_task_document(
                farm_id=farm_id,
                block_id=block_id,
                task_type="daily_harvest",
                title=f"Daily harvest for {crop_name}",
                description=f"Daily harvest for {block_name} ({crop_name})",
                scheduled_date=today,
                due_date=today.replace(hour=23, minute=59, second=59),
                trigger_state_change=None  # Daily harvest doesn't trigger state change
            )
            self.stats["tasks_by_type"]["daily_harvest"] += 1

        elif state == "cleaning":
            # Create cleaning task
            scheduled_date = today + timedelta(days=1)

            task = self.create_task_document(
                farm_id=farm_id,
                block_id=block_id,
                task_type="cleaning",
                title=f"Clean and sanitize {block_name}",
                description=f"Clean and prepare {block_name} for next cycle",
                scheduled_date=scheduled_date,
                due_date=scheduled_date + timedelta(days=3),
                trigger_state_change="empty"
            )
            self.stats["tasks_by_type"]["cleaning"] += 1

        return task

    async def populate_tasks(self):
        """Main method to populate tasks for all non-empty blocks."""
        blocks = await self.get_non_empty_blocks()

        print(f"\nPopulating tasks...")

        for block in blocks:
            block_id = block.get("blockId")
            block_name = block.get("name") or block.get("blockCode") or block_id[:8]
            state = block.get("state")

            self.stats["blocks_processed"] += 1

            # Check if block already has pending tasks
            if await self.has_pending_tasks(block_id):
                self.stats["blocks_with_existing_tasks"] += 1
                continue

            # Create task for this block
            task = await self.create_task_for_block(block)

            if not task:
                self.stats["blocks_skipped"] += 1
                continue

            if self.dry_run:
                print(f"  [DRY RUN] Would create {task['taskType']} task for {block_name} ({state})")
            else:
                result = await self.db["farm_tasks"].insert_one(task)
                if result.inserted_id:
                    self.stats["tasks_created"] += 1
                    print(f"  Created {task['taskType']} task for {block_name} ({state})")

    async def verify_results(self):
        """Verify the population results."""
        print("\n=== Verification ===")

        # Count tasks by type
        pipeline = [
            {"$match": {"status": "pending"}},
            {"$group": {"_id": "$taskType", "count": {"$sum": 1}}}
        ]
        result = await self.db["farm_tasks"].aggregate(pipeline).to_list(None)
        task_counts = {r["_id"]: r["count"] for r in result}

        print("\nPending tasks by type:")
        for task_type, count in sorted(task_counts.items()):
            print(f"  {task_type}: {count}")

        # Count blocks with pending tasks
        pipeline = [
            {"$match": {"status": "pending"}},
            {"$group": {"_id": "$blockId"}},
            {"$count": "total"}
        ]
        result = await self.db["farm_tasks"].aggregate(pipeline).to_list(None)
        blocks_with_tasks = result[0]["total"] if result else 0
        print(f"\nBlocks with pending tasks: {blocks_with_tasks}")

    def print_summary(self):
        """Print summary of population operation."""
        print("\n" + "=" * 60)
        print("POPULATION SUMMARY")
        print("=" * 60)

        print(f"\nBlocks processed: {self.stats['blocks_processed']}")
        print(f"Blocks with existing tasks (skipped): {self.stats['blocks_with_existing_tasks']}")
        print(f"Blocks skipped (no task needed): {self.stats['blocks_skipped']}")
        print(f"Tasks created: {self.stats['tasks_created']}")

        print("\nTasks by type:")
        for task_type, count in self.stats["tasks_by_type"].items():
            if count > 0:
                print(f"  {task_type}: {count}")

        if self.dry_run:
            print("\n*** This was a DRY RUN - no changes were made ***")


async def main():
    parser = argparse.ArgumentParser(
        description="Populate tasks for non-empty blocks based on their current state"
    )
    parser.add_argument(
        "--dry-run",
        action="store_true",
        help="Preview changes without modifying database"
    )
    args = parser.parse_args()

    print("=" * 60)
    print("POPULATE BLOCK TASKS")
    print("=" * 60)

    populator = TaskPopulator(dry_run=args.dry_run)

    try:
        await populator.connect()

        # Populate tasks
        await populator.populate_tasks()

        # Verify results
        await populator.verify_results()

        # Print summary
        populator.print_summary()

    finally:
        await populator.close()


if __name__ == "__main__":
    asyncio.run(main())
